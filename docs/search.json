[
  {
    "objectID": "posts/blog1/perceptron.html",
    "href": "posts/blog1/perceptron.html",
    "title": "Implementing the Perceptron Algorithm",
    "section": "",
    "text": "CS 0451\nPerceptron Class Source Code: https://github.com/kate-kenny/kate-kenny.github.io/blob/main/posts/blog1/perceptron.py\nTo implement the perceptron algorithm, I used the above source code to create a perceptron class and perform perceptron updates. The specific update is performed using the fit() method of the class. I implimented the update based on the perceptron equation which is as follows:\n\\[\\textbf{w}^{(t+1)} = \\textbf{w}^{t} + \\mathcal{1}(y_i\\langle \\textbf{w}^{(t)},\\textbf{x}_{i} \\rangle > 0)y_i\\textbf{x}_i\\]\nThe fit() method takes two arguments, a matrix \\(X\\) of features and a vector \\(y\\) of labels. The method then generates a random weight vector, reffered to as \\(w\\) in my source code, and then iterates through the possible maximum number of steps to perform the perceptron update. The actual update occurs in the following way. As enumerated in the description of the algoritm, once we have a random set of weights \\(w\\) we generate a random integer \\(i\\). From there, we index the feature matrix \\(X\\) and the label vector \\(y\\) using that integer \\(i\\) and perform the update which is, in plain language, as follows. The weights in \\(w\\) will be updated if the dot product of the current weights and \\(x_i\\) multiplied by the actual label of the point, \\(y_i\\) is less than zero. In other words, the weights will be changed if the given weights do not corrently label the point \\(x_i\\). If that is the case, we add\n\n\n\nFor the first test case, we are going to run the model on a linearly seperable data set and display the line calculated by the perceptron algorithm to seperate the data points. To do this, I will use the source code provided in class to generate data and then create an instance of my own perceptron class. Finally, we will display the data and seperating line, along with a visual representation of the accuracy over time.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom matplotlib import pyplot as plt2\n\n%load_ext autoreload\n%autoreload 2\n\nfrom sklearn.datasets import make_blobs\n\nnp.random.seed()\n\nn = 100\np_features = 3\n\n#initialize X, y, a martix of features and vector of labels respectively\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers = [(-1.7, -1.7), (1.7, 1.7)])\n\nplt.figure(1)\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\ntitle = plt.title(\"Test Case 1\")\n\nfrom perceptron import Perceptron\n\n#create instance of perceptron class and use the fit() method on X, y initialized above for the first test case\n\np = Perceptron()\np.fit(X,y)\n\n#draw line from weights found using perceptron algorithm\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nfig = draw_line(p.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\nplt.figure(2)\nfig2 = plt.plot(p.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\n\n\n\n\n\n\n\n\nNow, I am going to explore attempting to use the perceptron algorithm on a non-linearly seperable data set.\nFirst, using a similar process as above, I will generate a data set of non-linearly seperated data and then create another instance of the perceptron class. Then, I will use the fit() method to attempt to generate weights, \\(w\\), that will produce a line that will try and categorize the data.\nObviously, the algorithm will not converge but I will display the line generated to seperate the data after the full number of max steps has been concluded and also have a visualization of the accuracy throughout this process.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom matplotlib import pyplot as plt2\n\n%load_ext autoreload\n%autoreload 2\n\nfrom sklearn.datasets import make_blobs\n\nnp.random.seed()\n\nn = 100\np_features = 3\n\n#initialize X, y, a martix of features and vector of labels respectively\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers = [(-1, -1), (.5,.5)])\n\nplt.figure(1)\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\ntitle = plt.title(\"Test Case 1\")\n\nfrom perceptron import Perceptron\n\n#create instance of perceptron class and use the fit() method on X, y initialized above for the first test case\n\np = Perceptron()\np.fit(X,y)\n\n#draw line from weights found using perceptron algorithm\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nfig = draw_line(p.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\nplt.figure(2)\nfig2 = plt.plot(p.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload"
  },
  {
    "objectID": "posts/blog1/perceptron.html#conclusion-and-question",
    "href": "posts/blog1/perceptron.html#conclusion-and-question",
    "title": "Implementing the Perceptron Algorithm",
    "section": "Conclusion and Question",
    "text": "Conclusion and Question\nFinally, I want to consider the question posed on the assignment page. What is the runtime complexity of a single iteration of the perceptron algorithm update as described by the update equation?\nRecall the update equation.\n\\[\\textbf{w}^{(t+1)} = \\textbf{w}^{t} + \\mathcal{1}(y_i\\langle \\textbf{w}^{(t)},\\textbf{x}_{i} \\rangle > 0)y_i\\textbf{x}_i\\]\nThe runtime of the equation is \\(O(1)*p\\) where \\(n\\) is the number of data points and \\(p\\) is the number of features. It doesn’t seem like the number of data points \\(n\\) would influence the runtime since a single update is only dealing with one randomly selected data point. So, for the update we need to assign the randomly selected points and corresponding weights. Then, for each update, we also take the dot product of each feature with it’s corresponding weight, which is \\(p\\) operations. Hence, we must multiply the runtime by \\(p\\)."
  },
  {
    "objectID": "posts/blog2/Logistic Regression.html",
    "href": "posts/blog2/Logistic Regression.html",
    "title": "Optimization for Logistic Regression",
    "section": "",
    "text": "In this blog, I will explore optimization for logistic regression through the implementation of three optimization algorithms: simple gradient descent, a momentum method, and stochastic gradient descent. Through experimentation we will compare the performance of each of these algoritms for training logistic regression to predict binary classifiers for a data set.\nHere is a link to my source code for the LogisticRegression() module: https://github.com/kate-kenny/kate-kenny.github.io/blob/main/posts/blog2/logistic_regression.py\n\n\n\nFirst, we will implement standard gradient descent for logistic regression. This algorithm uses the following equation to calculate the gradient descent for \\(L(\\mathbf{w}) = \\frac{1}{n} \\sum_{i=1}^{n}l(f_{\\mathbf{w}}(\\mathbf{x_i}),y_i)\\) that we derived in class. The gradient can be calculated as follows.\n\\(\\nabla L(\\mathbf{w}) = \\frac{1}{n} \\sum_{i=1}^{n}{(\\sigma (\\hat{y_i}) - y_i)\\mathbf{x_i}}\\)\nMy approach to implementing this algorithm was somewhat similar to the way in which I implemented the perceptron algorithm last week. Similarly, the main method in my LogisticRegression class is a fit() method which takes in a matrix of features \\(X\\) and a vector of labels \\(y\\). The fit() method generates a random vector of weights, \\(w\\), and then updates that weight vector based on the gradient descent equation and update step. This results in an algorithm which can estimate the minimum of the loss function and as such gives a hyperplane (a line in our experiments) that can estimate the labels for data that is not linearly seperable.\n\nfrom logistic_regression import LogisticRegression # your source code\nfrom sklearn.datasets import make_blobs\nfrom matplotlib import pyplot as plt\nimport numpy as np\nnp.seterr(all='ignore') \n\n\n%load_ext autoreload\n%autoreload 2\n\n\n# make the data\np_features = 3\nX, y = make_blobs(n_samples = 200, n_features = p_features - 1, centers = [(-1, -1), (1, 1)])\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n#create instance of LogisticRegression Class and fit data \nLR = LogisticRegression()\nLR.fit(X, y, alpha=.001)\n\ndef draw_line(w, x_min, x_max):\n    x = np.linspace(x_min, x_max, 101)\n    y = -(w[0]*x + w[2])/w[1]\n    plt.plot(x, y, color = \"black\")\n\n#plot line using calculated weights \nfig = draw_line(LR.w, -2, 2)\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\n\n\n\n\n\nNext, I am going to implement the stochastic gradient descent algorithm for logistic regression optimization. Similar to the standard gradient descent algorithm used above, the stocashtic algorithm can be used to sort data that is not linearly seperable.\nInstead of computing the gradient as we did earlier, for this algorithm we compute the stochastic gradient by picking a random subset \\(S \\in [n]\\) and computing the following.\n\\(\\nabla L(\\mathbf{w}) = \\frac{1}{|S|} \\sum_{i=1}^{n}{(\\sigma (\\hat{y_i}) - y_i)\\mathbf{x_i}}\\)\nThe implementation of this algorithm is similar to that for gradient descent above but uses random batches of the data points and iterates through those batches to estimate the minimum of the loss function we are working with.\n\np_features = 3\nX, y = make_blobs(n_samples = 200, n_features = p_features - 1, centers = [(-1, -1), (1, 1)])\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\nLR = LogisticRegression()\nLR.fit_stochastic(X, y)\n\ndef draw_line(w, x_min, x_max):\n    x = np.linspace(x_min, x_max, 101)\n    y = -(w[0]*x + w[2])/w[1]\n    plt.plot(x, y, color = \"black\")\n\n#plot line using calculated weights \nfig = draw_line(LR.w, -2, 2)\n\n\n\n\n\n\n\n\nBelow is an illustration of the loss over epochs for the two algorithms implemented above: gradient descent and stochastic gradient descent. Both have an alpha of .001 and have the maximum number of epochs set to 10,000. It is interesting to observe that while both the stochastic and gradient start with similar loss values, the stochastic gradient loss decreases more rapidly the the standard gradient loss, as pictured below.\n\nLR = LogisticRegression()\nLR.fit_stochastic(X, y, \n                  max_epochs = 10000,  \n                  alpha = .001) \n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient\")\n\nLR = LogisticRegression()\nLR.fit(X, y, alpha = .001, max_epochs = 10000)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"gradient\")\n\nplt.loglog() \n\nlegend = plt.legend() \n\n\n\n\n\n\n\n\n\n\nNow, let’s examine a case where gradient descent does not converge because the selected alpha size is too large. Below is a plot of the loss of gradient descent with two different alpha values, .01 and 10. For this experiment, we are going to run the models on data with 10 feature dimensions.\n\n#Create data with 10 feature dimensions\np_features = 10\nX, y = make_blobs(n_samples = 200, n_features = p_features - 1, centers = [(-1, -1), (1, 1)])\n\n\nLR = LogisticRegression()\nLR.fit(X, y, alpha = 10, max_epochs = 1000)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"alpha = 10\")\n\nLR = LogisticRegression()\nLR.fit(X, y, alpha = .01, max_epochs = 1000)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"alpha = .01\")\n\n\nlegend = plt.legend() \n\n\n\n\n\n\n\nOur next experiment is the case where the batch size influences how quickly our algorithm (stochastic gradient descent) converges. To illustrate this, we are going to run the algorithm on two different batch sizes and examine the loss convergence. The larger batch size starts out with higher loss than the smaller batch, but it ends up converging around the same time, so the loss improves at a faster rate.\n\nLR = LogisticRegression()\nLR.fit_stochastic(X, y, \n                  max_epochs = 10000, \n                  batch_size = 10, \n                  alpha = .001) \n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient (batch size = 10)\")\n\nLR = LogisticRegression()\nLR.fit_stochastic(X, y, \n                  max_epochs = 10000, \n                  batch_size = 100, \n                  alpha = .001) \n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient (batch size = 100)\")\n\nplt.loglog() \n\nlegend = plt.legend()"
  },
  {
    "objectID": "posts/blog3/Palmer Penguins.html",
    "href": "posts/blog3/Palmer Penguins.html",
    "title": "Classifying Palmer Penguins",
    "section": "",
    "text": "Model Choices\n\nLogistic Regression\n\n#Trying Different Models and Plotting decision regions\nfrom sklearn.linear_model import LogisticRegression\n#from sklearn.ensemble import RandomForestClassifier\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom mlxtend.plotting import plot_decision_regions\n\n\nfrom matplotlib.patches import Patch\n\ndef plot_regions(model, X, y):\n    \n    x0 = X[X.columns[0]]\n    x1 = X[X.columns[1]]\n    qual_features = X.columns[2:]\n    \n    fig, axarr = plt.subplots(1, len(qual_features), figsize = (7, 3))\n\n    # create a grid\n    grid_x = np.linspace(x0.min(),x0.max(),501)\n    grid_y = np.linspace(x1.min(),x1.max(),501)\n    xx, yy = np.meshgrid(grid_x, grid_y)\n    \n    XX = xx.ravel()\n    YY = yy.ravel()\n\n    for i in range(len(qual_features)):\n      XY = pd.DataFrame({\n          X.columns[0] : XX,\n          X.columns[1] : YY\n      })\n\n      for j in qual_features:\n        XY[j] = 0\n\n      XY[qual_features[i]] = 1\n\n      p = model.predict(XY)\n      p = p.reshape(xx.shape)\n      \n      \n      # use contour plot to visualize the predictions\n      axarr[i].contourf(xx, yy, p, cmap = \"jet\", alpha = 0.2, vmin = 0, vmax = 2)\n      \n      ix = X[qual_features[i]] == 1\n      # plot the data\n      axarr[i].scatter(x0[ix], x1[ix], c = y[ix], cmap = \"jet\", vmin = 0, vmax = 2)\n      \n      axarr[i].set(xlabel = X.columns[0], \n            ylabel  = X.columns[1])\n      \n      patches = []\n      for color, spec in zip([\"red\", \"green\", \"blue\"], [\"Adelie\", \"Chinstrap\", \"Gentoo\"]):\n        patches.append(Patch(color = color, label = spec))\n\n      plt.legend(title = \"Species\", handles = patches, loc = \"best\")\n      \n      plt.tight_layout()\n\n\n    \ncols = [\"Culmen Length (mm)\", \"Culmen Depth (mm)\", \"Island_Dream\", \"Island_Biscoe\", \"Island_Torgersen\"]\n\nLR = LogisticRegression()\nLR.fit(X_train[cols], y_train)\nLR.score(X_train[cols], y_train)\n\nqual_features = [\"Island_Biscoe\", \"Island_Dream\", \"Island_Torgersen\"]\nplot_regions(LR, X_train[cols], y_train)\n\n/Users/katekenny/opt/anaconda3/envs/ml-0451/lib/python3.9/site-packages/sklearn/linear_model/_logistic.py:458: ConvergenceWarning: lbfgs failed to converge (status=1):\nSTOP: TOTAL NO. of ITERATIONS REACHED LIMIT.\n\nIncrease the number of iterations (max_iter) or scale the data as shown in:\n    https://scikit-learn.org/stable/modules/preprocessing.html\nPlease also refer to the documentation for alternative solver options:\n    https://scikit-learn.org/stable/modules/linear_model.html#logistic-regression\n  n_iter_i = _check_optimize_result(\n\n\n<bound method ClassifierMixin.score of LogisticRegression()>\n\n\n\n\n\n\n\nDecision Tree Classifier\n\nfrom sklearn.tree import DecisionTreeClassifier\n\nDT = DecisionTreeClassifier(max_depth = 7)\nDT.fit(X_train[cols], y_train)\n\nplot_regions(DT, X_train[cols], y_train)\n\n\n\n\n\nThis model achhieves a training accuracy score of 1, however from the plots alone it is clear that there is some overfitting occurring to achieve the perfect accuracy score. As a result, even though this model has the “best’ training score, it will likely not be the best model to make predictions on new data.\n\n\nSupport Vector Machine\n\nfrom sklearn.svm import SVC \n\n#NEED to cross validate to find gamma here \n\nsv = SVC(kernel=\"rbf\", gamma = 0.1)\nsv.fit(X_train[cols], y_train)\n\nplot_regions(sv, X_train[cols], y_train)\n\n\n\n\n\n\nTesting the models\nNow that we have trained a variety of models, we can score them on test data that the models have not yet seen.\n\ntest_url = \"https://raw.githubusercontent.com/middlebury-csci-0451/CSCI-0451/main/data/palmer-penguins/test.csv\"\ntest = pd.read_csv(test_url)\n\nX_test, y_test = prepare_data(test)\nprint(\"Logistic Regression Score: \") \nprint(LR.score(X_test[cols], y_test))\nprint(\"Decision Tree Score: \") \nprint(DT.score(X_test[cols], y_test))\nprint(\"Support Vector Machine Score: \")\nprint(sv.score(X_test[cols], y_test))\n\n\nLogistic Regression Score: \n1.0\nDecision Tree Score: \n0.9852941176470589\nSupport Vector Machine Score: \n0.9558823529411765\n\n\n\n\nResults and discussion\nFrom the results above, we can see that each of the three models considered and trained performed well with scores above .95. The model that performed the best on the test data was Logistic Regression, which had a perfect score of 1.0. So it seems that our process to choose features and train the models was successful and could be replicated on diifferent similar data sets to classify penguin species."
  },
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "This is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "Kate Kenny\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKate Kenny\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKate Kenny\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nAn example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Kate Kenny’s blog"
  }
]