[
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "This is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "An example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Kate Kenny’s blog"
  },
  {
    "objectID": "posts/blog1/perceptron.html",
    "href": "posts/blog1/perceptron.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "CS 0451\nPerceptron Class Source Code: https://github.com/kate-kenny/kate-kenny.github.io/blob/main/posts/blog1/perceptron.py\nTo implement the perceptron algorithm, I used the above source code to create a perceptron class and perform perceptron updates. The specific update is performed using the fit() method of the class. I implimented the update based on the perceptron equation which is as follows:\n\\[\\textbf{w}^{(t+1)} = \\textbf{w}^{t} + \\mathcal{1}(y_i\\langle \\textbf{w}^{(t)},\\textbf{x}_{i} \\rangle > 0)y_i\\textbf{x}_i\\]\nThe fit() method takes two arguments, a matrix \\(X\\) of features and a vector \\(y\\) of labels. The method then generates a random weight vector, reffered to as \\(w\\) in my source code, and then iterates through the possible maximum number of steps to perform the perceptron update. The actual update occurs in the following way. As enumerated in the description of the algoritm, once we have a random set of weights \\(w\\) we generate a random integer \\(i\\). From there, we index the feature matrix \\(X\\) and the label vector \\(y\\) using that integer \\(i\\) and perform the update which is, in plain language, as follows. The weights in \\(w\\) will be updated if the dot product of the current weights and \\(x_i\\) multiplied by the actual label of the point, \\(y_i\\) is less than zero. In other words, the weights will be changed if the given weights do not corrently label the point \\(x_i\\). If that is the case, we add\n\n\n\nFor the first test case, we are going to run the model on a linearly seperable data set and display the line calculated by the perceptron algorithm to seperate the data points. To do this, I will use the source code provided in class to generate data and then create an instance of my own perceptron class. Finally, we will display the data and seperating line, along with a visual representation of the accuracy over time.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom matplotlib import pyplot as plt2\n\n%load_ext autoreload\n%autoreload 2\n\nfrom sklearn.datasets import make_blobs\n\nnp.random.seed()\n\nn = 100\np_features = 3\n\n#initialize X, y, a martix of features and vector of labels respectively\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers = [(-1.7, -1.7), (1.7, 1.7)])\n\nplt.figure(1)\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\ntitle = plt.title(\"Test Case 1\")\n\nfrom perceptron import Perceptron\n\n#create instance of perceptron class and use the fit() method on X, y initialized above for the first test case\n\np = Perceptron()\np.fit(X,y)\n\n#draw line from weights found using perceptron algorithm\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nfig = draw_line(p.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\nplt.figure(2)\nfig2 = plt.plot(p.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload\n\n\n\n\n\n\n\n\n\n\n\nNow, I am going to explore attempting to use the perceptron algorithm on a non-linearly seperable data set.\nFirst, using a similar process as above, I will generate a data set of non-linearly seperated data and then create another instance of the perceptron class. Then, I will use the fit() method to attempt to generate weights, \\(w\\), that will produce a line that will try and categorize the data.\nObviously, the algorithm will not converge but I will display the line generated to seperate the data after the full number of max steps has been concluded and also have a visualization of the accuracy throughout this process.\n\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom matplotlib import pyplot as plt2\n\n%load_ext autoreload\n%autoreload 2\n\nfrom sklearn.datasets import make_blobs\n\nnp.random.seed()\n\nn = 100\np_features = 3\n\n#initialize X, y, a martix of features and vector of labels respectively\nX, y = make_blobs(n_samples = 100, n_features = p_features - 1, centers = [(-1, -1), (.5,.5)])\n\nplt.figure(1)\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\ntitle = plt.title(\"Test Case 1\")\n\nfrom perceptron import Perceptron\n\n#create instance of perceptron class and use the fit() method on X, y initialized above for the first test case\n\np = Perceptron()\np.fit(X,y)\n\n#draw line from weights found using perceptron algorithm\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X[:,0], X[:,1], c = y)\nfig = draw_line(p.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\nplt.figure(2)\nfig2 = plt.plot(p.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\nThe autoreload extension is already loaded. To reload it, use:\n  %reload_ext autoreload"
  },
  {
    "objectID": "warmups/warmup2-20.html",
    "href": "warmups/warmup2-20.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "from matplotlib import pyplot as plt \nimport math\nimport numpy as np\n\nfig1, ax1 = plt.subplots(1, 1) \nfig2, ax2 = plt.subplots(1,1)\n\nz = np.linspace(0.01,5)\nt = np.linspace(-1,.999)\n\n\nax1.set(xlabel = r\"$z$\", \n       ylabel = r\"$f(z)$\")\n\n\nax2.set(xlabel = r\"$z$\", \n       ylabel = r\"$g(z)$\")\n\nax1.plot(z, -1*np.log(z))\nax2.plot(t, -1*np.log(1-t))"
  },
  {
    "objectID": "posts/blog1/perceptron.html#conclusion-and-question",
    "href": "posts/blog1/perceptron.html#conclusion-and-question",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "Conclusion and Question",
    "text": "Conclusion and Question\nFinally, I want to consider the question posed on the assignment page. What is the runtime complexity of a single iteration of the perceptron algorithm update as described by the update equation?\nRecall the update equation.\n\\[\\textbf{w}^{(t+1)} = \\textbf{w}^{t} + \\mathcal{1}(y_i\\langle \\textbf{w}^{(t)},\\textbf{x}_{i} \\rangle > 0)y_i\\textbf{x}_i\\]\nThe runtime of the equation is \\(O(1)*p\\) where \\(n\\) is the number of data points and \\(p\\) is the number of features. It doesn’t seem like the number of data points \\(n\\) would influence the runtime since a single update is only dealing with one randomly selected data point. So, for the update we need to assign the randomly selected points and corresponding weights. Then, for each update, we also take the dot product of each feature with it’s corresponding weight, which is \\(p\\) operations. Hence, we must multiply the runtime by \\(p\\)."
  },
  {
    "objectID": "warmups/Untitled.html",
    "href": "warmups/Untitled.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "import numpy as np \n\nalpha = .01\nz_0 = np.random.rand(1, 2)\n\n\ndef f(x): \n    return np.sin(x[0]*x[1])\n\ndef grad(z): \n    return np.array([z[1]*np.cos(z[0]*z[1]), z[0]*np.cos(z[0]*z[1]) \n\ndef find_min(\nwhile diff != 0: \n    z_new = z_0 + aplha*grad(z_0)\n    diff = z_0 - z_new\n    \n    z_0 = z_new\n\nSyntaxError: invalid syntax (1208176260.py, line 14)"
  }
]